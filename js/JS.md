JavaScript

1.JS由哪三部分组成？
    ECMAScript：JS的核心内容，描述了语言的基础语法，比如var、for、数据类型（数组、字符串），
    文档对象模型（DOM）：DOM把整个HTML页面规划为元素构成的文档
    浏览器对象模型（BOM）：对浏览器窗口进行访问和操作
2.JS有哪些内置对象？
    String Boolean Number Array Object Funtion Math Date RegExp...
    Math
        abs()   sqrt()  max()   min()
    Date
        new Date()  getYear()   
    Array

    String
    concat() length slice() split()
3.操作数组的方法有哪些？
    push()  pop()   sort()  splice()    unshift()   reverse()   concat()    join()  map()   filter()
    every()    some()  reduce()    isArray()   findIndex()
    哪些方法会改变原数组？
    push()  pop()   unshift()   shift() sort()  reverse()   splice()
4.JS对数据类的检测方式有哪些？
    typeof()    对于基本数据类型没问题，遇到引用数据类型就不管用
    instanceof()    只能判断引用数据类型，不能判断基本数据类型
    constructor    几乎可以判断基本数据类型和引用数据类型;如果声明了一对构造函数并把它的原型指向了Array
    Object.prototype.toString.call()    完美解决了上述问题
5.说一下闭包，闭包有什么特点？
    什么是闭包？    函数嵌套函数，内部函数被外部函数返回并保存下来时，就会产生闭包
    特点：可以重复利用变量，并且这个变量不会污染全局的一种机制；这个变量是一直保存在内存中，不会被垃圾回收机制回收
    缺点：闭包较多的时候，会消耗内存，导致页面的性能下降，只有在IE浏览器中才会导致内存泄漏
    使用场景：防抖、节流、函数嵌套函数避免全局污染的时候
6.前端的内存泄漏怎么理解？
    JS里已经分配内存地址的对象，但是由于长时间没法释放或没法清除，造成长期占用内存的现象，会让内存资源大幅浪费，最终导致运行速度慢，甚至崩溃的情况。
    垃圾回收机制
    因素：一些未声明直接赋值的对象；一些未清空的定时器；过度的闭包；一些引用元素没有被清除
7.事件委托是什么？
    又叫事件代理，原理就是利用了事件冒泡的机制来实现，也就是说把子元素的事件绑定在父元素身上
    如果子元素阻止了事件冒泡，那么委托也就不成立
    阻止事件冒泡：event.stopPropagation()
    addEventListener('click', 函数名, true/false) 默认是false（事件冒泡），true（事件捕获）
    好处：提升性能，减少事件绑定，也就减少了内存占用
8.基本数据类型和引用数据类型的区别？
    基本数据类型：String Number Boolean undefined null
        基本数据类型保存在栈内存当中，保存的是一个具体的值
    引用数据类型（复杂数据类型）：Object Array Function Date
        引用数据类型保存在堆内存当中，声明一个引用类型的变量，它保存的是引用数据的地址
        如果声明两个引用类型同时指向了一个地址的时候，修改一个那么另一个也会改变
9.说一下原型链？
    原型就是一个普通对象，它是为构造函数的实例共享属性和方法；所有实例中引用的原型都是同一个对象
    使用prototype可以把方法挂在原型上，内存值保留一份
    __proto__可以理解为指针，实例对象中的属性，指向了构造函数的原型（prototype）
    一个实例对象在调用属性和方法的时候，会依次从实例本身、构造函数原型、原型的原型上去查找
10.new操作符具体做了什么？
    1）先创建一个空对象
    2）把空对象和构造函数通过原型链进行连接
    3）把构造函数的this绑定到新的空对象身上
    4）根据构造函数的返回类型判断，如果是值类型，则返回对象，如果是引用，就要返回这个引用类型
11.JS是如何实现继承的？
    1）原型链继承
        让一个构造函数是另一个类的实例，那么这个构造函数new出来的实例就是该实例的属性
        优点：写法方便简单，容易理解
        缺点：对象实例共享所有继承的属性和方法。无法像父类构造函数传参。
    2）借用构造函数继承
        在子类构造函数的内部调用父类构造函数；使用apply()或call()方法将父对象的构造函数绑定在子对象上
        优点：解决了原型继承不能传参的问题和父类圆形共享的问题
        缺点：方法都在构造函数内定义，无法实现函数复用。在父类原型中定义的方法，对子类是不可见的，结果所有类只能使用构造函数模式。
    3）组合式继承
        将 原型链 和 借用构造函数 组合到一起。使用原型链对原型的属性和方法继承，而通过借用构造函数来实现对实例属性的继承。
        这样，既通过在原型上定义方法实现函数复用，又能保证每个实例都有自己的属性
        优点：解决了原型链继承和借用构造函数继承造成的影响
        缺点：无论在什么情况下，都会调用两次父类的构造函数；一次是在创建子类原型的时候，另一次是在子类构造函数内部
    4）ES6的class类继承
        Class通过extends关键字实现继承，其实质是先创造出来父类的this对象，然后用子类的构造函数修改this
        子类构造方法必须调用super方法，只有在调用super()后才能使用this，
        因为子类的this是继承父类的this，然后对其进行了加工，而super方法表示父类的构造函数用来新建父类的this对象
        优点：语法简单易懂，操作更为方便
        缺点：并不是所有的浏览器都支持class关键字
12.JS的设计原理是什么？
    JS引擎  运行上下文  调用栈  事件循环    回调
13.JS中关于this指向的问题
    1）全局中的this指向
        指向的是window
    2）全局作用域或者普通函数中的this
        指向全局window
    3）this永远指向最后调用它的那个对象
        在不是箭头函数的情况下
    4）new关键词改变了this指向
    5）apply,call,bind
        可以改变this指向，不是箭头函数
    6）箭头函数中的this
        它的指向在定义的时候就已经确定了
        箭头函数它没有this，看外层是否有函数，有就是外层函数的this，没有就是window
    7）匿名函数中的this
        永远指向window，匿名函数的指向环境具有全局性，因此this指向window  
14.script标签里的async和defer有什么区别？
    当没有async和defer
        浏览器会立即加载并执行指定的脚本
    有async
        加载和渲染后面元素的过程将和script的加载和执行并行进行（异步）
    有defer
        加载和渲染后面元素的过程将和script的加载并行进行（异步），但是它的执行事件要等所有元素解析完之后才能进行
15.setTimeout最小执行时间是多少？
    HTML5规定的内容：
    setTimeout最小执行时间是4ms
    setInterval最小执行时间10ms
16.ES6和ES5有什么区别？
17.ES6的新特性有哪些？
18.call，apply，bind三者有什么区别？
19.用递归的时候有没有遇到什么问题？
20.如何实现一个深拷贝？
21，说一下事件循环
22.ajax是什么？怎么实现的？
23.get和post有什么区别？
24.promise的内部原理是什么？它的优缺点是什么？
25.promise和async、await的区别是什么？
